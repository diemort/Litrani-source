// @(#)root/html:$Id: TElecCascade.cpp 2008-06-11
// Author: F.X. Gentit <http://gentit.home.cern.ch/gentit/>

/*************************************************************************
* Copyright (C) Those valid for CNRS software.                          *
*************************************************************************/
#include "TROOT.h"
#include "TLitGlob.h"
#include "TMessErr.h"
#include "TOpticMaterial.h"
#include "TSupplShape.h"
#include "TSNode.h"
#include "TEqIndex.h"
#include "TResults.h"
#include "TPublication.h"
#include "TPhotonCradle.h"
#include "TPhoton.h"
#include "TElecCascade.h"

ClassImp(TElecCascade)
//______________________________________________________________________________
//
// TElecCascade defines an electromagnetic shower, propagating inside a
//given material. All shapes of the setup containing the given material will
//be affected by the cascade.
//
// PHYSICAL CHARACTERISTICS
//
//  ( 1) The energy of the cascade is E0
//  ( 2) y == E0/Ec , Ec being the critical energy of the material associa-
//         ted with the cascade.
//  ( 3) The longitudinal profile of the cascade is according to the formu-
//         la (23.25), page 148, of the "Review of Particle Physics" :
//
//            dE/dt = (E0*b*((bt)^(a-1))*exp(-bt))/Gamma(a)
//
//  ( 4) b is taken equal to 0.5
//  ( 5) tmax == ln(y) +Cj   [Cj = +0.5 for gamma, -0.5 for electron indu-
//          ced cascades ]
//  ( 6) a is obtained from tmax == (a-1)/b
//  ( 7) The longitudinal spread of the cascade is stopped abruptly after
//         20 radiations lengths.
//  ( 8) The lateral spread of the cascade is taken as (23.27) :
//
//           f(r) = (K^2/pi)/(r^2 + K^2)^2)
//
//        such that :
//
//           Integral[f(r)*r*dr*dphi] == 1
//
//  ( 9) K is chosen such that 90% of the energy is contained in 1 Moliere
//         radius Rm, which gives K = Rm/3 .
//  (10) The lateral spread of the cascade is stopped abruptly at r = 3.5 Rm
//
// PARAMETERS OF THE CONSTRUCTOR :
//
//  name     : name of this electromagnetic shower.
//  title    : title of this electromagnetic shower.
//  E0       : energy in Gev of the cascade. Will be transformed into Mev
//  StartCasc: Starting point of the cascade, IN THE LOCAL COORDINATES of
//             the shape "namesh". [cm]
//  AxisCasc : axis of the cascade, pointing from start to end, IN THE
//             LOCAL COORDINATES of the shape "namesh".
//  namemat  : material in which the cascade propagates itself. All shapes
//             of the setup made of this material and reached by the cascade
//             will generate photons due to the energy deposit of the casca-
//             de. It is necessary for that that this material be fluores-
//             cent ( call to TOpticMaterial::FluoComponent() have been
//             made ). It is not necessary that TOpticMaterial::dEdx() has
//             been called. A call to TOpticMaterial::SetPhotMev() is
//             enough to indicate how many photon to generate per Mev of
//             energy deposited by the cascade. For this material, do not
//             forget to call TOpticMaterial::SetCascades().
//  namesh   : name of the shape used as reference for giving the coordin-
//             nates of the cascade.
//  gamma    : if true, cascade is generated by a gamma, if false by an
//             electron. Default gamma.
//  photfac  : Due to the fact that the number of photons generated by an
//             electromagnetic shower is fantastically high, each job using
//             Litrani for generating electromagnetic showers would take
//             hours or even days to accomplish. You have the possibility,
//             using photfac, to reduce the number of emitted photons by
//             photfac to save time. Default 0.05
//  stepl    : number of steps along the axis of the cascade. Default 100.
//  stepr    : number of steps in r. Default 35.
//  stepf    : number of steps in phi. Default 120. It means 420000 steps in
//             all ! Be warned that everything has to be slow when handling
//             electromagnetic showers !
//

Double_t TElecCascade::fZmaxLR   = 24.0;
Double_t TElecCascade::fRmaxMR   =  3.5;

TElecCascade::TElecCascade(const char *name, const char *title, Double_t E0,
  T3Vector StartCasc, T3Vector AxisCasc, const char *namemat,const char *namesh,
  Bool_t gamma, Double_t photfac, Int_t stepl,Int_t stepr, Int_t stepf):TNamed(name,title) {
  //Constructor for an electromagnetic shower
  //
  // PARAMETERS OF THE CONSTRUCTOR :
  //
  //  name     : name of this electromagnetic shower.
  //  title    : title of this electromagnetic shower.
  //  E0       : energy in Gev of the cascade. Will be transformed into Mev
  //  StartCasc: Starting point of the cascade, IN THE LOCAL COORDINATES of
  //             the shape "namesh". [cm]
  //  AxisCasc : axis of the cascade, pointing from start to end, IN THE
  //             LOCAL COORDINATES of the shape "namesh".
  //  namemat  : material in which the cascade propagates itself. All shapes
  //             of the setup made of this material and reached by the cascade
  //             will generate photons due to the energy deposit of the casca-
  //             de. It is necessary for that that this material be fluores-
  //             cent ( call to TOpticMaterial::FluoComponent() have been
  //             made ). It is not necessary that TOpticMaterial::dEdx() has
  //             been called. A call to TOpticMaterial::SetPhotMev() is
  //             enough to indicate how many photon to generate per Mev of
  //             energy deposited by the cascade. For this material, do not
  //             forget to call TOpticMaterial::SetCascades().
  //  namesh   : name of the shape used as reference for giving the coordin-
  //             nates of the cascade.
  //  gamma    : if true, cascade is generated by a gamma, if false by an
  //             electron. Default gamma.
  //  photfac  : Due to the fact that the number of photons generated by an
  //             electromagnetic shower is fantastically high, each job using
  //             Litrani for generating electromagnetic showers would take
  //             hours or even days to accomplish. You have the possibility,
  //             using photfac, to reduce the number of emitted photons by
  //             photfac to save time. But be aware that you degrade by
  //             that the representation of the cascade. With a very small
  //             value of photfac, most of the volume elements used to build
  //             the cascade will generate 0 photons ! The default of 0.05
  //             has to be considered as a lower limit for a shower of 10 Gev
  //             in a material producing 100 photons per Mev.
  //             Default 0.05 !
  //  stepl    : number of steps along the axis of the cascade. Default 100.
  //  stepr    : number of steps in r. Default 35.
  //  stepf    : number of steps in phi. Default 120. It means 420000 steps in
  //             all ! Be warned that everything has to be slow when handling
  //             electromagnetic showers !
  //
  const Double_t zero = 0.0;
  const Double_t   un = 1.0;
  const Double_t limp = 0.1;
  TOpticMaterial *pmat;
  TSupplShape *psup;
  TString s;
  Double_t tmax,y;
  Bool_t found = kFALSE;
  InitP();
  fPhotFac = TMath::Abs(photfac);
  fNStepL  = stepl;
  fNStepR  = stepr;
  fNStepF  = stepf;
  gLit->VerifyOutside();
  fRun = -1;
  if (!gGs)
    gGs = new TResults("GlobStat","Global statistics of all runs",0);
  FirstStep();
  TIter next1(&gLit->fOptMat);
  while((!found) && (pmat = (TOpticMaterial *)next1())) {
    s = pmat->GetName();
    if (!s.CompareTo(namemat)) {
      found = kTRUE;
      fMat  = pmat;
    }
  }
  if (!found) {
    s = namemat;
    gMes->SetName("TElecCascade");
    gMes->SetTitle("TElecCascade");
    gMes->M(kill_prog,1,"This material has not been found",s);
  }
  found = kFALSE;
  TIter next2(&gLit->fSupplShape);
  while ((!found) && (psup = (TSupplShape *)next2())) {
    s = psup->GetName();
    if (!s.CompareTo(namesh)) {
      found = kTRUE;
      fRefShape  = psup;
      fSNode = fRefShape->GetNode();
    }
  }
  if (!found) {
    s = namesh;
    gMes->SetName("TElecCascade");
    gMes->SetTitle("TElecCascade");
    gMes->M(kill_prog,2,"This shape has not been found",s);
  }
  fSNode->LocalToWorld(StartCasc,fStart);
  AxisCasc.Unit();
  fSNode->AxisToWorld(AxisCasc,fZaxis);
  fZaxis.Unit();
  CascCoordSys();
  //
  //  Getting the physical parameters of the cascade
  //
  fE0 = 1000*E0;
  if (gamma) fCj =  0.5;
  else       fCj = -0.5;
  fX0      = fMat->GetX0();
  fRm      = fMat->GetRm();
  fEc      = fMat->GetEc();
  if ((fX0<=zero) || (fRm<=zero) || (fEc<=zero)) {
    gMes->SetName("TElecCascade");
    gMes->SetTitle("TElecCascade");
    gMes->M(Error_M,3,"Material not initialized for cascades");
    gMes->M(kill_prog,3,"Please call TOpticMaterial::SetCascades");
  }
  fZmax    = fZmaxLR*fX0;
  fRmax    = fRmaxMR*fRm;
  fB       = 0.5;
  y        = fE0/fEc;
  tmax     = TMath::Log(y) + fCj;
  fA       = fB*tmax + un;
  fK       = fRm/3.0;
  fFacdEdz = (fE0*fB)/(fX0*TMath::Gamma(fA));
  fFacdEdr = (fK*fK)/TMath::Pi();
  fDStepL  = fZmax/fNStepL;
  fDStepR  = fRmax/fNStepR;
  fDStepF  = (2*TMath::Pi())/fNStepF;
  if (!gIdx) {
    gIdx = new TEqIndex("TElecCascade");
    if (gMes->TestCalc()) gIdx->SetDebug();
  }
  Int_t nstep;
  Double_t phottot,photres,photvol;
  nstep   = fNStepL*fNStepR*fNStepF;
  phottot = fE0*fMat->GetPhotMev();
  photres = phottot*fPhotFac;
  photvol = photres/nstep;
  gMes->SetName("TElecCascade");
  gMes->SetTitle("TElecCascade");
  gMes->M(Info_M,3,"Number of volume elements",nstep);
  gMes->M(Info_M,3,"Expected number of photons for full generation",phottot);
  gMes->M(Info_M,3,"Expected number of photons for this generation",photres);
  if (photvol<limp) {
    gMes->M(Warning_M,4,"Diminishing factor for number of photons very small",
      fPhotFac);
    gMes->M(Warning_M,4,"Most volume elements with 0 photons",photvol);
  }
}
TElecCascade::~TElecCascade() {
  // Destructor. TElecCascade is not owner of fMat, fSNode, fRefShape. Do not
  //delete them.
  if (fBeam) {
    delete fBeam;
    fBeam = 0;
  }
  if (fPhot) {
    delete fPhot;
    fPhot = 0;
  }
}
void TElecCascade::CascCoordSys() {
  //  Complement fZaxis with fXaxis and fYaxis, the coordinate system of the
  //cascade.
  Double_t eps1,eps2;
  T3Vector Ox(1.0,0.0,0.0);
  T3Vector Oy(0.0,1.0,0.0);
  eps1 = Ox*fZaxis;
  eps2 = Oy*fZaxis;
  if (eps1<=eps2) fXaxis = Ox;
  else            fXaxis = Oy;
  fXaxis.MinOrthoN(fZaxis,eps1,eps2);
  fYaxis = fZaxis^fXaxis;
  fYaxis.Unit();
}
void TElecCascade::CoordStep() {
  //  Finds the coordinates of the volume element (fIStepL,fIStepR,fIStepF),
  //both in cascade coordinate system and in WCS.
  const Double_t demi = 0.5;
  T3Vector p(0);
  Double_t x;     //Coord x of volume element in coord. sys. of cascade
  Double_t y;     //Coord y of volume element in coord. sys. of cascade
  fZcasc = fDStepL*(fIStepL + demi);
  fRcasc = fDStepR*(fIStepR + demi);
  fFcasc = fDStepF*(fIStepF + demi);
  x      = fRcasc*TMath::Cos(fFcasc);
  y      = fRcasc*TMath::Sin(fFcasc);
  p      = fStart + x*fXaxis + y*fYaxis + fZcasc*fZaxis;
  fX     = p(0);
  fY     = p(1);
  fZ     = p(2);
}
Double_t TElecCascade::DeltaE(Double_t &deltaV, Double_t &EperV) const {
  //  Calculates volume element [deltaV], energy per cm3 [EperV] and energy
  //deposited in the volume element [return value = deltaV*EperV], for the
  //step (fIStepL,fIStepR,fIStepF).
  //  Also determines the coordinates (fX,fY,fZ) of the volume element in WCS
  //
  const Double_t un   = 1.0;
  Double_t a;
  Double_t t;     //Coord z of volume element in rad. L for this step
  Double_t dEdz;  //Energy per longitudinal cm (23.25)
  Double_t dEdr;  //Energy per radial cm (23.27)
  Double_t E;     //deposited energy in volume element
  t      = fZcasc/fX0;
  deltaV = fDStepL*fRcasc*fDStepR*fDStepF;
  dEdz   = fFacdEdz*TMath::Exp((fA-un)*TMath::Log(fB*t))*TMath::Exp(-fB*t);
  a      = (fRcasc*fRcasc + fK*fK);
  dEdr   = fFacdEdr/(a*a);
  EperV  = dEdz*dEdr;
  E      = EperV*deltaV;
  return E;
}
void TElecCascade::EmitLight(Double_t E,TSupplShape *psup) {
  //  Emit the corrresponding number of photons for a deposited energy of
  //E Mev at the point fX,fY,fZ in the shape psup made of material fMat.
  Int_t i,nphot,nphot1,nphot2;
  Int_t kfluo,bin;
  Axis_t afluo;
  Double_t x,aphot,rphot;
  T3Vector x0,K,Elec;
  //Number of photons to generate
  aphot = E*fPhotFac*fMat->GetPhotMev();
  nphot = (Int_t) aphot;
  rphot = aphot - nphot;
  x = gRandom3->Rndm();
  if (x<=rphot) nphot += 1;
  nphot1 = fNphot + 1;
  nphot2 = fNphot + nphot;
  //
  // Loop on generation of photons
  //
  for (i=nphot1;i<=nphot2;i++) {
    gGs->fNpGener += 1;
    if (gCs) gCs->fNpGener += 1;
    //first determines wavelength and time of emission of photon and store results
    //in histograms
    fMat->WaveAndLife(fWvlgth,fT0,kfluo);
    //update all values depending upon wavelength
    gLit->NewWavelength(fWvlgth);
    bin = gGs->fHTimeAll->Fill(fT0);
    bin = gGs->fHWvlgthAll->Fill(fWvlgth);
    if (gCs) {
      bin = gCs->fHTimeAll->Fill(fT0);
      bin = gCs->fHWvlgthAll->Fill(fWvlgth);
    }
    if (gGs->HasFluo()) {
      afluo = kfluo;
      bin = gGs->fHTimeEach->Fill(fT0,afluo);
      bin = gGs->fHWvlgthEach->Fill(fWvlgth,afluo);
    }  //if (gGs->HasFluo())
    if ((gCs) && (gCs->HasFluo())) {
      afluo = kfluo;
      bin = gCs->fHTimeEach->Fill(fT0,afluo);
      bin = gCs->fHWvlgthEach->Fill(fWvlgth,afluo);
    }  //if (gCs)
    //generates the photon
    fBeam->Generate(x0,K,Elec);
    fPhot = new TPhoton(fRun,i,x0,psup,fWvlgth,fT0,K,Elec,0);
    //follow the photon from its birth to its death
    fPhot->Move(-1);
    if (gGs->fNpAbnorm>TLitPhys::Get()->Anomalies()) {
      gMes->SetName("Gen");
      gMes->SetTitle("TSpontan");
      gMes->M(kill_prog,2,"too many anomalies");
    }
    delete fPhot;
    fPhot = 0;
  }//end for loop on photons
  fNphot += nphot;
}
void TElecCascade::FirstStep() {
  //Initializes step counters
  fIStepL = 0;
  fIStepR = 0;
  fIStepF = 0;
  fNphot  = 0;
}
void TElecCascade::Gen(Int_t run, Double_t xparam, Bool_t runstat,Bool_t ForgetLast) {
  //
  //  Generates the photons produced by the cascade in all shapes made of the
  //material declared in the constructor of TElecCascade. For all shapes not
  //made of this material, nothing happens.
  //
  //  PARAMETERS :
  //
  //  run        : run number. Arbitrary, but has to be greater than 0.
  //
  //  xparam     : this parameter is used as abscissa in the plotting of the
  //               results by the class TPublication. For instance, if you
  //               have a setup with a crystal and you make 10 runs varying
  //               the y coordinate of the starting point of the cascade in
  //               fStart, you can choose this y coordinate as xparam. All
  //               plots provided by TPublication will then have this y
  //               coordinate as abscissa. You will get efficiency versus
  //               y coordinate of starting point of cascade, and so on. If
  //               you do not give xparam, or give a value smaller than
  //               -1.0e+20, all plots of TPublication will have the run
  //               number as abscissa.
  //
  //  runstat and ForgetLast :
  //
  //    if runstat == true [Default] AND ForgetLast == false [Default] :
  //
  //      in memory   : this run statistics keeped but this run histos deleted
  //                     when next run begins
  //      on the file : this run statistics and histos recorded
  //
  //            It is the only configuration which allows the working of
  //          TPublication, i.e. allowing to show histograms of quantities
  //          varying as a function of a run dependent parameter.
  //          Usage : normal case : try it first.
  //
  //    if runstat == true AND ForgetLast == true :
  //
  //      in memory   : this run statistics and histograms deleted when next
  //                     run begins.
  //      on the file : this run statistics and histos recorded
  //
  //          Disadvantage : TPublication not working, gGp pointer unavailable
  //          Advantage    : no increase of memory with runs
  //                         per run histograms still available on file
  //          Usage : use this configuration when your number of runs is big
  //                  but you still want per run statistics and histograms
  //                  on file.
  //
  //    if runstat == false ( ForgetLast true or false ) :
  //
  //      in memory   : no statistics and histograms for this run
  //      on the file : no statistics and histograms for this run
  //
  //          Disadvantage : TPublication not working, gGp pointer unavailable
  //                         per run statistics and histograms not available
  //          Advantage    : no increase of memory with runs
  //                         a bit faster, half less histograms to fill
  //          Usage : use this configuration when your number of runs is very
  //                  big and you are not interested in the per run statistics
  //                  and histograms.
  //
  //  Notice that in any case, the global statistics and histograms for all
  //runs is always present in memory and on the file. This global statistics
  //is an object of class TResults, pointed to by the pointer gGs.
  //
  const Double_t zero = 0.0;
  Bool_t gGpok;
  gGs->RefreshDet();
  if (run<=0) {
    gMes->SetName("Gen");
    gMes->SetTitle("TElecCascade");
    gMes->M(Error_M,1,"run number must be >= 1. We change it !");
    run = TMath::Abs(run);
    if (run==0) run += 1;
  }
  fRun = run;
  //Insures that gOutside is defined
  OutsideOk();
  //Defines fFullName
  NameFile();
  //initializes the summary statistics of class TPublication
  gGpok = (runstat && (!ForgetLast));
  if (!gGp && gGpok) gGp = new TPublication("Summary","Runs",gGpok);
  //Verifies that shapes are numbered
  Int_t nbofsh;
  if (!gLit->fShapeNumbered)
    nbofsh = gLit->GiveNbToShape();
  //Handle the pointer to the previous run. Even if gCs is put to 0 without
  //having been deleted, pointer to the previous run is not lost, it stays
  //inside gLit->fResults.
  if (gCs) {
    if (ForgetLast) {
      gLit->fResults.Remove(gCs);
      delete gCs;
      gCs = 0;
    }
    else gCs->DelHistos();
  }
  gCs = 0;
  //Makes gCs point towards this run.
  if (runstat) gCs = new TResults(fFullName,fTitle,fRun,xparam);
  //Open the .root file for writing, if not yet done
  if (gLit->fFilesClosed) {
    gLit->OpenFilesW(runstat);
    gROOT->cd();
    if ((!runstat) && (gCs)) {
      delete gCs;
      gCs = 0;
    }
  }
  //emission of light in all shapes
  Bool_t finished;
  Double_t deltaV,EperV;
  Double_t dEp;
  TString s;
  T3Vector center(0);
  TSupplShape *psup;
  TOpticMaterial *pmat;
  TIter next(&gLit->fSupplShape);
  while ((psup = (TSupplShape *)next())) {
    if (psup->IsFluorescent()) {
      pmat = psup->GetOptMat();
      if (pmat == fMat) {
        s = psup->GetName();
        gMes->SetName("Gen");
        gMes->SetTitle("TElecCascade");
        gMes->M(Info_M,2,"Shape found for cascade",s);
        fEdeposit = zero;
        fVdeposit = zero;
        finished = kFALSE;
        FirstStep();
        while (!finished) {
          CoordStep();
          if (psup->IsInside(fX,fY,fZ)) {
            center.Set(fX,fY,fZ);
            fBeam = new TPhotonCradle(psup,center);
            dEp = DeltaE(deltaV,EperV);
            fEdeposit += dEp;
            fVdeposit += deltaV;
            EmitLight(dEp,psup);
            delete fBeam;
            fBeam = 0;
          }//end if (psup->IsInside(fX,fY,fZ))
          finished = NextStep();
        }//end while (!finished)
        gMes->SetName("Gen");
        gMes->SetTitle("TElecCascade");
        gMes->M(Info_M,2,"Energy deposited",fEdeposit);
        gMes->M(Info_M,2,"Into volume",fVdeposit);
        gMes->M(Info_M,2,"Number of photons",fNphot);
      }//end if (pmat == fMat)
    }//end if (psup->IsFluorescent())
  }//end while (psup = (TSupplShape *)next())
  //Put statistics of this run into the tree.
  if (gCs) {
    gCs->Conclusion();
    gLit->fLitFile->cd();
    gLit->fLitNb += gLit->fLitTree->Fill();
    gROOT->cd();
  }
}
void TElecCascade::InitP() {
  // Pointers to 0
  fPhot     = 0;
  fMat      = 0;
  fSNode    = 0;
  fBeam     = 0;
  fRefShape = 0;
}
void TElecCascade::NameFile() {
  //Give a name to the statistics and histogram file for one run.
  //The name of the statistics and histograms file for a run is fName ( the
  //name you have given in the constructor of TElecCascade) appended with '_'
  //followed by the run number and '.root'. For instance, if you have given
  //the name "casc100Gev" to this instance of TElecCascade, and you call Gen()
  //with run number 100, the name of the file will be "casc100Gev_100.root".
  const Int_t kBufferSize = 64;
  Int_t l,l1;
  TString NameOnly;
  NameOnly = fName;
  l1 = kBufferSize - 10;
  l = NameOnly.Length();
  if (l>l1) NameOnly.Remove(l1);
  fFullName  = NameOnly;
  fFullName.Append('_');
  fFullName += fRun;
}
Bool_t TElecCascade::NextStep() {
  //Go to next step. Returns true if last step.
  Bool_t last = kFALSE;
  fIStepF += 1;
  fIStepF %= fNStepF;
  if (!fIStepF) {
    fIStepR += 1;
    fIStepR %= fNStepR;
    if (!fIStepR) {
      fIStepL += 1;
      fIStepL %= fNStepL;
      if (!fIStepL) last = kTRUE;
    }
  }
  return last;
}
void TElecCascade::OutsideOk() const {
  //Insures that gOutside is defined
  if (!gOutside) {
    Bool_t b;
    gOutside = new TOpticMaterial("Outside","Material of the outside world",
      kFALSE,1.0,1.0e+6);
    gOutside->IsIsotropic(1.0);
    b = gOutside->CheckIt();
  }
}
