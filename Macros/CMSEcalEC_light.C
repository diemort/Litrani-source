{
//
//	BEGIN OF CMSEcalEC.C
//
// We call gROOT->Reset() if bit 16 not set. See explanation in InitLitrani.C
  if (!gROOT->TestBit(65536)) {
    gROOT->Reset();
    cout << endl;
    cout << "  --> gROOT->Reset() called" << endl;
  }
  const TString Tiret     = "_";
  const Short_t verbosity = 3;           //0-3
  Int_t    iwvlgth;
  Int_t    i1;
  char     ccc;
  char  *downcom;
  TString  FullName;
  Int_t    nbphot          = 50000;
  Int_t    typelight       = 0;
  Double_t ebeam           = 120.0;
  Int_t    iebeam;
  Double_t wvlgth          = 440.0;
  Short_t WhereFib = 0;
  Short_t DamageIntensity = 0; //[0-6] intensity of radiation damages in this shape
  TString DamageFile = "RadDamage_Kim0";
  Short_t kOptAxis = 0;  //Position of optical axis
  while ((kOptAxis<1) || (kOptAxis>2)) {
    cout << endl;
    cout << "You have the choice between 2 positionning for" << endl;
    cout << " the optical axis:" << endl;
    cout << " (1) - like the russian crystals" << endl;
    cout << " (2) - like the chinese crystals" << endl;
    cout << "  Your choice : ";
    cin  >> kOptAxis;
  }
  while ((typelight<1) || (typelight>2)) {
    cout << "You have the choice between 2 types of light emission" << endl;
    cout << " (1) : Light issued from Fibre"   << endl;
    cout << " (2) : Light generated by an e- electromagnetic shower" << endl;
    cout << "What is your choice ? ";
    cin  >> typelight;
  }
  while ((WhereFib < 1) || WhereFib > 2)) {
    cout << "You can choose between 2 positions for the fibre:" << endl;
    cout << " (1) - Near intersection of AR/BR" << endl;
    cout << "      light     || to lateral face" << endl;
    cout << " (2) - Near intersection of AR and opposite side to BR" << endl;
    cout << "      light not || to lateral face" << endl;
    cout << "Your choice : ";
    cin >> WhereFib;
  }
  if (typelight == 1) {
    cout << endl;
    cout << "Unit is 1000 photons (kilo-photons!)" << endl;
    cout << "How many kilo-photons do you want ? ";
    cin  >> nbphot;
    nbphot *= 1000;
    cout << endl;
    cout << "The wavelength for the led is : " << wvlgth << endl;
    cout << "Do you want to change the wavelength of the laser ? y or n ";
    cin  >> ccc;
    if (ccc=='y'){
      cout << "wavelength of the laser : ";
      cin  >> wvlgth;
    }
    iwvlgth = wvlgth;
  }
  else {
    cout << "The energy of the beam is : " << ebeam << endl;
    cout << "Do you want to change the energy of the beam ? y or n ";
    cin  >> ccc;
    if (ccc=='y') {
      cout << "Energy of the beam : ";
      cin  >> ebeam;
    }
  }
  iebeam = ebeam;
  cout << endl;
  cout << "You have the choice between 7 levels of irradiation damages" << endl;
  cout << "The level actually chosen is 0 : no radiation damage" << endl;
  cout << "Do you want to change it ? ";
  cin  >> ccc;
  if (ccc=='y') {
    DamageIntensity = -1;
    while ((DamageIntensity<0) || (DamageIntensity>6)) {
      cout << "Enter damage intensity [0-6] : ";
      cin  >> DamageIntensity;
    }
  }
  DamageFile += DamageIntensity;
  switch (typelight) {
    case 1:
      FullName = "EClaser_";
      char *downcom = "Light issued from Fibre";
      i1 = TMath::Abs(iwvlgth);
      break;
    case 2:
      FullName = "ECebeam_";
      char *downcom = "e- electromagnetic shower";
      i1 = iebeam;
      break;
  }
  if (kOptAxis==1) FullName.Append('B');
  else             FullName.Append('C');
  FullName += Tiret;
  FullName += i1;
  FullName += Tiret;
  FullName += WhereFib;
  FullName += Tiret;
  FullName.Append("dam");
  FullName += DamageIntensity;
  if (verbosity>=2) {
    cout << endl;
    cout << "Root file: " << FullName.Data() << endl;
    cout << endl;
  }
  char *name    = FullName.Data();
  char *listing = FullName.Data();
  char *upcom   = "Simulation of CMS Endcap crystal";
  gROOT->ProcessLine(".x InitLitrani.C(1,name,listing,upcom,downcom,kTRUE,kFALSE,kTRUE)");
//
// arguments of InitLitrani:
//
// size     = 0 | 1 | 2 | 3 according to the size you want for the canvas
// name     name of the produced ROOT file (without ".root")
// listing  name of the listing file (without ".lis")
// upcom    name of the comment appearing on top    left of canvas
// downcom  name of the comment appearing on bottom left of canvas
// otherseq true if one wants an other sequence of random numbers at each new launching
// indebug  true if one wants to run Litrani2 in debug mode
// WithDate if true, appends date and time to name of root file and name of listing
//
  gROOT->ProcessLine(".x CMSEcalEC_setup.C");
//
// End setting setup
//
  const    Int_t ndatafile   = 7;
  const    Int_t ndata0      = 0;
  const    TString Damagefilesprefix = "RadDamage_Kim0";
  const    TString Labsfilesprefix = "AbsorptionLength_crys8981R0";
  Bool_t   damok;
  Double_t calcsize;
  Int_t    irun;
  Int_t    idata;
  Int_t    jdata;
  TString  Damagefile;
  TString  Labsfile;
  Double_t ebeamirrad      = 120.0;
  Double_t photfac         = 0.1;
  Double_t efficiency[ndatafile];
  Double_t erroreff[ndatafile];
  Double_t dosis[ndatafile];
  Int_t    PrintFreq = 50000;
//  if (typelight > 1) PrintFreq = ( ebeam * PhotMeV * 1000.0 * photfac ) / 5;
//  else               PrintFreq = nbphot / 5;
  gLit->SetPrintFreq(PrintFreq);
//
// Generation of photons
//
  Double_t xparam;
  Int_t nbrun;
  switch (typelight) {
   case 1:
     TSpontan *laser;
     laser = new TSpontan("laser","laser","Fibre",wvlgth,0);
     laser->DefineBeam(provided,MaxApert,"AngularDistrib_FibreCMS");
     cout << endl;
     cout << "How many IDENTICAL runs do you want : ";
     cin  >> nbrun;
     for (irun=1;irun<=nbrun;irun++) {
       xparam = irun;
       laser->Gen(irun,nbphot,xparam);
     }
     break;
   case 2:
      if (verbosity >= 1) then {
        cout << endl;
        cout << "  Entry point of beam : " << endl;
        start_casc->Print();
        cout << "Axis of beam" << endl;
        axis_casc->Print();
        cout << endl;
      }
      TElecCascade *beam;
      beam = new TElecCascade("Beam","Beam",ebeam,start_casc,axis_casc,"PbWO4","Crystal",
                              kFALSE,photfac);
      cout << endl;
      cout << "How many electromagnetic showers do you want to generate: ";
      cin  >> nbrun;
      for (irun=1;irun<=nbrun;irun++) {
        xparam = irun;
        beam->Gen(irun,xparam);
      }
     break;
  }
  switch (typelight) {
   case 1:
     gGp->SetTitle("run number");
     break;
   case 2:
     gGp->SetTitle("generated Cascade");
     break;
  }
  gGp->Summary(); //Summary() creates all summary histograms
  gGs->DoStat();
  gLit->CloseFiles();
  gLit->HistosManager();
}
