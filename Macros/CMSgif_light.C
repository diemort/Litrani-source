{
//
//  BEGIN OF GIF_light.C
//
//
  const Double_t zero = 0.0;
  const Double_t un   = 1.0;
  const Double_t minus_un = -un;
  const Double_t deux = 2.0;
  const Double_t pi = TMath::Pi();
  const Double_t photfac = 0.002;
  const Int_t ndatafile = 7;
  const Int_t ndata0 = 0;
  Int_t irun, idata, jdata;
  Double_t efficiency[ndatafile], erroreff[ndatafile];
  Double_t dosis[ndatafile];
  Double_t calcsize;
  Int_t typelight = 0;
  Int_t crystaltype = 0;
  Int_t typerevcrystal = 0;
  Double_t wvlgth = -465.0;
  Int_t iwvlgth;
  char ccc;
  Double_t ebeam = 120.0;
  Int_t iebeam;
  Int_t i3;
  Int_t nbphot = 50000;
  TString fFullName;
  char *downcom;
  while ((typelight<1) || (typelight>3)) {
    cout << "You have the choice between 3 types of light:" << endl;
    cout << " (1) : led     Light issued from Fibre1"   << endl;
    cout << "                wavelength fixed or spectrum of hcp200" << endl;
    cout << " (2) : laser   Light issued from a disk inside the crystal" << endl;
    cout << "                spectrum of the PbWO4" << endl;
    cout << " (3) : shower  Light generated by an e- electromagnetic shower" << endl;
    cout << "                spectrum of the PbWO4" << endl;
    cout << "What is your choice ? ";
    cin  >> typelight;
    cout << "typelight : " << typelight << endl;
  }
  while ((crystaltype<1) || (crystaltype>17)) {
    cout << "Crystal Type for CMS are from 1 to 17" << endl;
    cout << "What is your choice ? ";
    cin  >> crystaltype;
    cout << "crystaltype : " << crystaltype << endl;
  }
  switch (typelight) {
    case 1:
      cout << "The wavelength for the led is : " << wvlgth << endl;
      cout << "Do you want to change the wavelength of the laser ? y or n ";
      cin  >> ccc;
      if (ccc=='y'){
        cout << "wavelength of the laser : ";
        cin  >> wvlgth;
      }
      iwvlgth = wvlgth;
      i3      = TMath::Abs(iwvlgth);
      break;
    case 2:
      i3      = 0;
      break;
    case 3:
      cout << "The energy of the beam is : " << ebeam << endl;
      cout << "Do you want to change the energy of the beam ? y or n ";
      cin  >> ccc;
      if (ccc=='y') {
        cout << "Energy of the beam : ";
        cin  >> ebeam;
      }
      iebeam = ebeam;
      i3     = iebeam;
      break;
  }
  while ((typerevcrystal<1) || (typerevcrystal>6)) {
    cout << "There are 6 possible wrappings for the crystal :" << endl;
    cout << " (1) : tyvek" << endl;
    cout << " (2) : 100% absorbing" << endl;
    cout << " (3) : perfect diffusor" << endl;
    cout << " (4) : perfect reflector" << endl;
    cout << " (5) : pseudo tyvek" << endl;
    cout << " (6) : none" << endl;
    cout << "What is your choice ? ";
    cin  >> typerevcrystal;
  }
  if (typelight != 3) {
    cout << "How many photons do you want ? ";
    cin  >> nbphot;
  }
  switch (typelight) {
    case 1:
      fFullName = "led_";
      char *downcom = "led     Light issued from Fibre1";
      break;
    case 2:
      fFullName = "UV_laser_";
      char *downcom = "laser   Light issued from a disk inside the crystal";
      break;
    case 3:
      fFullName = "e_beam_";
      char *downcom = "shower  Light generated by an e- electromagnetic shower";
      break;
  }
  fFullName += crystaltype;
  fFullName.Append('_');
  fFullName += i3;
  fFullName.Append('_');
  fFullName += typerevcrystal;
  char *name    = fFullName.Data();
  char *listing = fFullName.Data();
  char *upcom   = "Simulation of GIF setup of experiment CMS";
  gROOT->ProcessLine(".x InitLitrani.C(6,name,listing,upcom,downcom,kFALSE,kFALSE,kTRUE)");
//
// arguments of InitLitrani:
//
// size     = 0 | 1 | 2 | 3 according to the size you want for the canvas
// name     name of the produced ROOT file (without ".root")
// listing  name of the listing file (without ".lis")
// upcom    name of the comment appearing on top    left of canvas
// downcom  name of the comment appearing on bottom left of canvas
// otherseq true if one wants an other sequence of random numbers at each new launching
// indebug  true if one wants to run Litrani2 in debug mode
// WithDate if true, appends date and time to name of root file and name of listing
//
  for (idata = 0; idata < ndatafile; idata++) {
    dosis[idata] = idata + 1;
  }
  gLit->SetPrintFreq(10000);
  gROOT->ProcessLine(".x CMSgif_setup.C");
  switch (typelight) {
    case 1:
//led
// ??? : ??? spurious?
      TSpontan *led;
//      if (iwvlgth > 0): led = new TSpontan("Led","Led","Fibre1",wvlgth,1);
//      else: led = new TSpontan("Led","Led","Fibre1",1);
//
// iwvlgth>0 ==> iwvlgth used
// iwvlgth<0 ==> FluoComponent of hcp200 used
//
      if (iwvlgth > 0) led = new TSpontan("Led","Led","Fibre1",wvlgth,1);
      else             led = new TSpontan("Led","Led","Fibre1",1);
      led->DefineBeam(provided,22.5,"AngularDistrib_FibreCMS");
    break;
//
    case 2:
//laser
      TSpontan *laser;
// émission à partir d'un volume près de la face d'entrée du crystal Non?
// émission à partir d'une surface (disque) près de la face d'entrée du crystal
//Spectre du PbWO4 utilisé.
      laser = new TSpontan("Laser","Laser","Crystal",airgapmixer_x,
              airgapmixer_y,-crys_dz+0.01);
      laser->DefineCradle("Crystal",disk,airgapmixer_r); 
      laser->DefineBeam(on4pi,180.0);
    break;
    case 3:
//shower
      Double_t startcasc_x = ( x0 + x1 + x2 + x3 ) / 4.0;
      Double_t startcasc_y = ( y0 + y1 + y2 + y3 ) / 4.0;
      Double_t startcasc_z = - crys_dz;
      T3Vector startcasc(startcasc_x,startcasc_y,startcasc_z);
      T3Vector axiscasc(zero,zero,un);
      TElecCascade *beam120GeV;
      beam120GeV = new TElecCascade("Beam120GeV","Beam120GeV",ebeam,startcasc,
                   axiscasc,"PbWO4","Crystal",kFALSE,photfac);
    break;
  }

  const Int_t nrun0 = 100; 
  for (idata = ndata0; idata < ndata0 + ndatafile; idata++) {
    irun = idata + nrun0;   
    switch (irun) {
    case 100:
//file 1
    break;
    case 101:
//file 2
      pbwo4->SetAbsLa("AbsorptionLength_crys8981R02", kFALSE);
    break;
    case 102:
//file 3
      pbwo4->SetAbsLa("AbsorptionLength_crys8981R03", kFALSE);
    break;
    case 103:
//file 4
      pbwo4->SetAbsLa("AbsorptionLength_crys8981R04", kFALSE);
    break;
    case 104:
//file 5
      pbwo4->SetAbsLa("AbsorptionLength_crys8981R05", kFALSE);
    break;
    case 105:
//file 6
      pbwo4->SetAbsLa("AbsorptionLength_crys8981R06", kFALSE);
    break;
    case 106:
//file 7
      pbwo4->SetAbsLa("AbsorptionLength_crys8981R07", kFALSE);
    break;
    case 107:
//file 1/10
      pbwo4->SetAbsLa("AbsorptionLength_crys8981R01b", kFALSE);
    break;
    }

    switch (typelight) {
      case 1:
// led
        led->Gen(irun,nbphot,dosis[idata]);
      break;
      case 2:
// laser
        laser->Gen(irun,nbphot,dosis[idata]);
      break;
      case 3:
// shower
        beam120GeV->Gen(irun,dosis[idata]);
      break;
    }
  }
//  It is a good idea to make a drawing of the setup. Any geometrical mistake will
//appear as an awful drawing ! Notice however that ROOT has a very strange and
//questionable way of drawing a setup : the proportion of the 3 axis are not
//respected by ROOT ! ROOT feels free to affect different factor to the 3 axis Ox,
//Oy and Oz ! So do not be surprised by the proportions !
//  node1->cd();
  node1->Draw();
  gLit->ChangePad();
//
  gGp->SetTitle("Absorption file");
//Summary() creates all summary histograms
  gGp->Summary();
  gGs->DoStat();
  for (idata = 0; idata < ndatafile; idata++) {
    jdata = ndata0 + idata + 1;
    efficiency[idata] = gGp->fHEfficiency->GetBinContent(jdata);
    erroreff[idata] = gGp->fHEfficiency->GetBinError(jdata);
  }
//  gMes->W(fFullName.Data());
//  gMes->W("results");
//  for (idata = 0; idata < ndatafile; idata++) {
//   jdata = ndata0 + idata + 1;
//    gMes->W(" ",jdata,efficiency[idata],erroreff[idata]);
//  }

    cout << endl << "Crystal type : " << crystaltype << endl;
    switch (typerevcrystal) {
    case 1:
        cout << "Crystal revetment : Tyvek";
    break;
    case 2:
        cout << "Crystal revetment : Totally absorbing";
    break;
    case 3:
        cout << "Crystal revetment : Perfect diffusor";
    break;
    case 4:
        cout << "Crystal revetment : Perfect reflector";
    break;
    case 5:
        cout << "Crystal revetment : Pseudo tyvek";
    break;
    case 6:
        cout << "Crystal revetment : none";
    break;
  }
  switch (typelight) {
    case 1:
//led
      cout << endl <<"LED light injection" << endl;
      cout << "Wavelength : " << iwvlgth << " nm ; Number of photons per run : " 
           << nbphot << endl;
    calcsize = nbphot;
    break;
    case 2:
//laser
      cout << endl <<"Laser stimulated emission" << endl;
      cout << "Number of photons per run : " << nbphot << endl;
    calcsize = nbphot;
    break;
    case 3:
//shower
      cout << endl <<"Electron shower" << endl;
      cout << "Energy : " << iebeam << " GeV  ; photofraction : " << photfac 
           << endl;
    calcsize = photfac;
    break;
  }
  cout << endl << "file;efficiency;error;n" << endl;
  for (idata = 0; idata < ndatafile; idata++) {
    jdata = ndata0 + idata + 1;
    cout << jdata << ";" << efficiency[idata] << ";" << erroreff[idata] << ";" << calcsize << endl;
  }
  cout << endl;
//  gGp->DrawEfficiency();
  gLit->CloseFiles();
}
